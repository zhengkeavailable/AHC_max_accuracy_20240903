import initial_sol
import numpy as np


def heaviside_closed(lb, x):
    if x >= lb:
        return 1
    else:
        return 0


def heaviside_open(lb, x):
    if x > lb:
        return 1
    else:
        return 0


def calculate_gamma(obj_cons_num, X_train, y_train, weights, bias, beta_p, epsilon):
    N = len(X_train)
    item_plus = [N, N]
    item_minus = [0, N]
    z_plus_start = {}
    z_minus_start = {}
    sum_tp = sum(heaviside_closed(0, min(y_train[s], np.dot(weights, X_train[s]) + bias)) for s in range(N))
    sum_dm = sum(heaviside_open(-epsilon, np.dot(weights, X_train[s]) + bias) for s in range(N))
    # gamma = max(0, - (sum_tp - beta_p * sum_dm))
    gamma = max(0, - (sum_tp - beta_p * sum_dm))
    for i in range(obj_cons_num):
        z_plus_start[i] = {}
        z_minus_start[i] = {}
        for j in range(item_plus[i]):
            if i == 0:
                z_plus_start[i][j] = heaviside_closed(0, y_train[j]*(np.dot(weights, X_train[j]) + bias))
            if i == 1:
                z_plus_start[i][j] = heaviside_closed(0, min(y_train[j], np.dot(weights, X_train[j]) + bias))
        for j in range(item_minus[i]):
            if i == 1:
                z_minus_start[i][j] = heaviside_closed(0, -(np.dot(weights, X_train[j]) + bias) - epsilon)
    return gamma, z_plus_start, z_minus_start  # if gamma > 0, initial solution generated by LinearClassifier is not feasible


def calculate_delta(obj_cons_num, item_plus, item_minus, X, y, weight, bias, epsilon, base_rate):
    value_ge = []
    value_le = []
    for i in range(obj_cons_num):
        index_odd = 0
        for j in range(item_plus[i]):
            if i == 0:
                if y[j]*(np.dot(weight, X[j]) + bias) > 0:
                    value_ge.append(y[j]*(np.dot(weight, X[j]) + bias))
                elif y[j]*(np.dot(weight, X[j]) + bias) < 0:
                    value_le.append(y[j]*(np.dot(weight, X[j]) + bias))
                else:
                    if index_odd == 0:
                        value_ge.append(y[j]*(np.dot(weight, X[j]) + bias))
                    else:
                        value_le.append(y[j]*(np.dot(weight, X[j]) + bias))
                    index_odd += 1
            if i == 1:
                if min(y[j], np.dot(weight, X[j]) + bias) > 0:
                    value_ge.append(min(y[j], np.dot(weight, X[j]) + bias))
                elif min(y[j], np.dot(weight, X[j]) + bias) < 0:
                    value_le.append(min(y[j], np.dot(weight, X[j]) + bias))
                else:
                    if index_odd == 0:
                        value_ge.append(min(y[j], np.dot(weight, X[j]) + bias))
                    else:
                        value_le.append(min(y[j], np.dot(weight, X[j]) + bias))
                    index_odd += 1
        for j in range(item_minus[i]):
            if i == 1:
                if -(np.dot(weight, X[j]) + bias) - epsilon > 0:
                    value_ge.append(-(np.dot(weight, X[j]) + bias) - epsilon)
                elif -(np.dot(weight, X[j]) + bias) - epsilon < 0:
                    value_le.append(-(np.dot(weight, X[j]) + bias) - epsilon)
                else:
                    if index_odd == 0:
                        value_ge.append(-(np.dot(weight, X[j]) + bias) - epsilon)
                    else:
                        value_le.append(-(np.dot(weight, X[j]) + bias) - epsilon)
                    index_odd += 1
    delta_1 = np.percentile(value_ge, base_rate)
    delta_2 = -np.percentile(value_le, 100 - base_rate)
    return delta_1, delta_2
# Example usage:
# file_path = 'C:/Users/zhengke/Desktop/24_07/20240704/BinaryClassification/bank+marketing/bank/bank.csv'
# learning_rate = 0.1
# n_iters = 1000
# results = initial_sol.train_and_evaluate(file_path, learning_rate, n_iters)
# weights = results['weights']
# bias = results['bias']
# X_train = results['X_train']
# print(X_train[0])
# y_train = 2 * results['y_train']-1
# beta_p = 0.7  # adjust by yourself
# print(calculate_gamma(X_train, y_train, weights, bias, beta_p))
